<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>My page</title>
	</head>

	<body>
		<header>
			<nav>
				<ul>
					<li><a href="#">Меню 1</a></li>
					<li><a href="#">Меню 2</a></li>
				</ul>
			</nav>
		</header>
		<main>
			<section>
				<h1>Мотивация</h1>
				<p>
					Я, как
					<span style="color: red">технический директор &amp; &#38; </span>,
					регулярно сталкиваюсь с необходимостью обсудить с командой архитектуру
					нового приложения или микросервиса. И в рамках таких обсуждений
					<sup><a href="./exercises/article-layout.html">1</a></sup> я понял,
					что не существует единого подхода, который позволил бы эффективно
					общаться команде, обсуждая архитектурные<sub>2</sub>
					решения.
				</p>
				<hr />
				<p>
					Понятно, что на словах это не объяснишь и приходится прибегать к
					дополнительным инструментам в виде доски и маркера или же при текущих
					реалиях - online доски типа Miro. Но даже в этом случае обсуждение
					сваливается в хаотично нарисованные квадратики, круги или
					прямоугольники с текстом, как-то соединённые стрелками.
				</p>
				<p>
					При этом от обсуждения к обсуждению одна и так же схема может быть
					нарисована 1000 разными способами. Кто-то в творческом порыве начинает
					рисовать иконки пользователей или серверов, а кто-то рисует поток из
					10 стрелок, чтобы показать все возможные варианты взаимодействия. И
					это - не эффективная коммуникация, где одно и тоже можно понять
					по-разному при этом потратив какое-то время на пояснение чем
					шестиугольник отличается круга.
				</p>
				<h1>А что есть?</h1>
				<p>
					Осознав проблемы я первым делом начал искать готовые варианты. Вот
					несколько из них:
				</p>
				<ul>
					<li>
						Диаграмма классов - иногда бывает удобной для анализа уже
						существующего кода, но не применима для изначального проектирования,
						где мы оперируем более верхне уровневыми объектами.
					</li>
					<li>
						c4model - уже ближе к теме и предлагает 4 уровня детализации схемы
						программного обеспечения. Но часто из всех 4-х уровней подходит 3-й,
						когда мы планируем новый сервис, а на 3-м уровне стандартов описания
						немного. Отлично подходит для верхнего уровня описания системы, но
						при детализации на компоненты не имеет детальных стандартов.
					</li>
				</ul>
				<p>
					Потому после нескольких экспериментов, я решил подготовить простую
					нотацию, которая позволит описать архитектуру приложений на том
					уровне, чтобы мы могли:
				</p>
				<ul>
					<li>
						Она должна на верхнем уровне описывать отделимые части системы,
						которые далее я буду назвать «компоненты».
					</li>
					<li>
						Связи между ними должны описать зависимости и поток вызовов, но не
						быть слишком усложнены. По связям должно быть сразу понятно наличии
						архитектурных ошибок.
					</li>
					<li>
						Схема должна подходить как для описания монолитного приложения, так
						и микросервисной архитектору.
					</li>
					<li>
						Фокус должен быть на описании нашей архитектуры, максимально
						абстрагировавшись от внешних систем.
					</li>
				</ul>
				<p>
					Ниже будет написано мое видение такой нотации с учётом опыта
					тестирования её вместе с командой. На практике она позволила в
					кратчайшие сроки обсуждать изменения в архитектуре или планировать
					полноценные новые сервисы или приложения.
				</p>
				<h1>Требования к нотации</h1>
				<p>
					Перед тем, как переходить к описанию предлагаемой нотации следует
					сформулировать требования, которым она должна удовлетворять:
				</p>
				<ul>
					<li>
						Она должна на верхнем уровне описывать отделимые части системы,
						которые далее я буду назвать «компоненты».
					</li>
					<li>
						Связи между ними должны описать зависимости и поток вызовов, но не
						быть слишком усложнены. По связям должно быть сразу понятно наличии
						архитектурных ошибок.
					</li>
					<li>
						Схема должна подходить как для описания монолитного приложения, так
						и микросервисной архитектору.
					</li>
					<li>
						Фокус должен быть на описании нашей архитектуры, максимально
						абстрагировавшись от внешних систем.
					</li>
				</ul>
				<p>
					Ниже будет написано мое видение такой нотации с учётом опыта
					тестирования её вместе с командой. На практике она позволила в
					кратчайшие сроки обсуждать изменения в архитектуре или планировать
					полноценные новые сервисы или приложения.
				</p>
				<h1>Структура диаграммы</h1>
				<p>
					В первую очередь давайте перечислим все возможные блоки, которые могут
					использоваться в диаграмме:
				</p>
				<ul>
					<li>
						Приложения - отделимые приложения для описания микросервисного
						подхода.
					</li>
					<li>Модули - объединяют компоненты.</li>
					<li>Компоненты - основные строительные блоки приложения.</li>
					<li>
						Внутренние связи между компонентами - обозначение связей между
						компонентами.
					</li>
					<li>Внешние связи - с другими системами или между микросервисами.</li>
					<li>Передаваемые объекты - между компонентами системы или вне</li>
					<li>
						Детализация полей, которые могут быть детальным описанием свойств,
						методов и структуры данных.
					</li>
				</ul>
				<h1>Компоненты</h1>
				<p>
					Стоит начать рассмотрение именно с компонент, так как они являются
					строительными блоками всей нашей диаграммы. Это изолированный с точки
					зрения логики кусок кода, который может в реальности представлять
					собой класс или отдельный файл.
				</p>
				<p>Это может быть:</p>
				<ul>
					<li>Контроллер, которые обрабатывает входящие запросы.</li>
					<li>Сервис, отвечающий за бизнес логику работы с платежами.</li>
					<li>Репозиторий, взаимодействующий с базой данных.</li>
					<li>Обработчик event событий при использовании event sourcing.</li>
					<li>
						Бизнес entity пользователя, содержащие поля для него и методы
						работы.
					</li>
				</ul>
				<p>
					Фактически все, что вы можете выделить в виде класса с
					инкапсулированной логикой - это компонент.
				</p>
				<p>
					Для того чтобы максимально полно описать компонент можно указать
					следующие параметры:
				</p>
				<ul>
					<li>
						Имя - название компонента, отражающие его суть или даже название
						класса.
					</li>
					<li>Тип - чтобы понять что это контроллер или репозиторий.</li>
					<li>Пояснение - если требуется дополнительное описание.</li>
				</ul>
				<p>Примеры:</p>
				<img
					src="../html-and-css-course-1/images/image1.jpg"
					alt="Примеры оформления блоков в архитектуре"
				/>
			</section>
			<section>
				<table>
					<caption>
						Структура расходов
					</caption>
					<thead>
						<tr>
							<th rowspan="2">Статья</th>
							<th colspan="2">Сумма</th>
						</tr>
						<tr>
							<th>Руб</th>
							<th>$</th>
						</tr>
					</thead>
					<tbody>
						<tr>
							<td>Зарплата</td>
							<td>100000</td>
							<td>2000</td>
						</tr>
						<tr>
							<td>Сервисы</td>
							<td>30000</td>
							<td>700</td>
						</tr>
					</tbody>
					<tfoot>
						<td>Итог</td>
						<td>130000</td>
						<td>2300</td>
					</tfoot>
				</table>
			</section>
		</main>
		<footer>Футер</footer>
	</body>
</html>
